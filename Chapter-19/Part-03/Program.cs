// Связь между типами данных в запросе

// Как показывает предыдущий пример, запрос включает в себя переменные, типы
// которых связаны друг с другом. К их числу относятся переменная запроса, переменная
// диапазона и источник данных. Соблюсти соответствие этих типов данных очень важно,
// но в то же время нелегко — по крайней мере, так кажется на первый взгляд, поэтому
// данный вопрос заслуживает более пристального внимания.

// Тип переменной диапазона должен соответствовать типу элементов, хранящихся
// в источнике данных. Следовательно, тип переменной диапазона зависит от типа
// источника данных. Как правило, тип переменной диапазона может быть выведен
// средствами С#. Но выводимость типов может быть осуществлена при условии, что
// в источнике данных реализована форма интерфейса IEnumerable<T>, где Т обозначает
// тип элементов в источнике данных. (Как упоминалось выше, форма интерфейса
// IEnumerable<T> реализуется во всех массивах, как, впрочем, и во многих других источниках
// данных.) Но если в источнике данных реализован необобщенный вариант
// интерфейса IEnumerable, то тип переменной диапазона придется указывать явно.
// И это делается в операторе from. Ниже приведен пример явного объявления типа
//int переменной диапазона n.

// var posNums = from int n in nums
// // ...

// Очевидно, что явное указание типа здесь не требуется, поскольку все массивы неявно
// преобразуются в форму интерфейса IEnumerable<T>, которая позволяет вывести
// тип переменной диапазона.

// Тип объекта, возвращаемого по запросу, представляет собой экземпляр интерфейса
// IEnumerable<T>, где Т — тип получаемых элементов. Следовательно, тип переменной
// запроса должен быть экземпляром интерфейса IEnumerable<T>, а значение
// Т должно определяться типом значения, указываемым в операторе select. В предыдущих
// примерах значению Т соответствовал тип int, поскольку переменная n имела
// тип int. (Как пояснялось выше, переменная n относится к типу int, потому что элементы
// именно этого типа хранятся в массиве nums.) С учетом явного указания типа
// IEnumerable<int> упомянутый выше запрос можно было бы составить следующим образом.

// IEnumerable<int> posNums = from n in nums
// where n > 0
// select n;

// Следует иметь в виду, что тип элемента, выбираемого оператором select, должен
// соответствовать типу аргумента, передаваемого форме интерфейса IEnumerable<T>,
// используемой для объявления переменной запроса. Зачастую при объявлении переменных
// запроса используется ключевое слово var вместо явного указания ее типа,
// поскольку это дает компилятору возможность самому вывести соответствующий тип
// данной переменной из оператора select. Как будет показано далее в этой главе, такой
// подход оказывается особенно удобным в тех случаях, когда оператор select возвращает
// из источника данных нечто более существенное, чем отдельный элемент.

// Когда запрос выполняется в цикле foreach, тип переменной шага цикла должен
// быть таким же, как и тип переменной диапазона. В предыдущих примерах тип этой
// переменной указывался явно как int. Но имеется и другая возможность: предоставить
// компилятору самому вывести тип данной переменной, и для этого достаточно указать
// ее тип как var. Как будет показано далее в этой главе, ключевое слово var приходится
// использовать и в тех случаях, когда тип данных просто неизвестен.

// Общая форма запроса

// У всех запросов имеется общая форма, основывающаяся на ряде приведенных ниже
// контекстно-зависимых ключевых слов.

// Ascending        by      descending      equals
// from             group   in              into
// join             let     on              orderby
// select           where

//Среди них лишь приведенные ниже ключевые слова используются в начале операторов запроса.

// from     group       join        let
// orderby  select      where

// Запрос должен начинаться с ключевого слова from и оканчиваться ключевым словом
// select или group. Оператор select определяет тип значения, перечисляемого
// по запросу, а оператор group возвращает данные группами, причем каждая группа
// может перечисляться по отдельности. Как следует из приведенных выше примеров,
// в операторе where указываются критерии, которым должен удовлетворять искомый
// элемент, чтобы быть полученным по запросу. А остальные операторы позволяют уточнить
// запрос. Все они рассматриваются далее по порядку.

// Отбор запрашиваемых значений с помощью оператора where

// Как пояснялось выше, оператор where служит для отбора данных, возвращаемых
// по запросу. В предыдущих примерах этот оператор был продемонстрирован в своей
// простейшей форме, в которой для отбора данных используется единственное условие.
// Однако для более тщательного отбора данных можно задать несколько условий
// и, в частности, в нескольких операторах where. В качестве примера рассмотрим следующую
// программу, в которой из массива выводятся только те значения, которые положительны
// и меньше 10.

//Использовать несколько операторов where.

using System;
using System.Linq;

class TowWheres
{
    static void Main()
    {
        int[] nums = { 1, -2, 3, -3, 0, -8, 12, 19, 6, 9, 10 };

        //Сформировать запрос на получение положительных значений меньше 10.
        var posNums = from n in nums
                      where n > 0
                      where n < 10
                      select n;

        Console.Write("Положительные значения меньшие 10: ");

        // Выполняем запрос и выводим результаты.
        foreach (int i in posNums)
        {
            Console.Write(i + " ");
        }

        // Задержка программы.
        Console.ReadKey();
    }
}

// Эта программа дает следующий результат.

// Положительные значения меньше 10: 1 3 6 9

// Как видите, по данному запросу извлекаются только положительные значения
// меньше. 10. Этот результат достигается благодаря двум следующим операторам where.

// where n > 0
// where n < 10

// Условие в первом операторе where требует, чтобы элемент массива был больше
// нуля. А условие во втором операторе where требует, чтобы элемент массива был меньше
// 10. Следовательно, запрашиваемый элемент массива должен находиться в пределах
// от 1 до 9 (включительно), чтобы удовлетворять обоим условиям.

// В таком применении двух операторов where для отбора данных нет ничего дурного,
// но аналогичного эффекта можно добиться с помощью более компактно составленного
// условия в единственном операторе where. Ниже приведен тот же самый запрос,
// переформированный по этому принципу.

// var posNums = from n in nums
// where n > 0 & n < 10
// select n;
