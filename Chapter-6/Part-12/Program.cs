// Еще раз об операторе new

// Теперь, когда вы ближе ознакомились с классами и их конструкторами, вернемся
// к оператору new, чтобы рассмотреть его более подробно. В отношении классов общая
// форма оператора new такова:

// new имя_класса(список_аргументов)

// где имя_класса обозначает имя класса, реализуемого в виде экземпляра его объекта.
// А имя_класса с последующими скобками обозначает конструктор этого класса. Если
// в классе не определен его собственный конструктор, то в операторе new будет использован
// конструктор, предоставляемый в C# по умолчанию. Следовательно, оператор new
// может быть использован для создания объекта, относящегося к классу любого типа.

// Оперативная память не бесконечна, и поэтому вполне возможно, что оператору
// new не удастся распределить память для объекта из-за нехватки имеющейся оперативной
// памяти. В этом случае возникает исключительная ситуация во время выполнения
// (подробнее об обработке исключительных ситуаций речь пойдет в главе 13). В примерах
// программ, приведенных в этой книге, ситуация, связанная с исчерпанием оперативной
// памяти, не учитывается, но при написании реальных программ такую возможность,
// вероятно, придется принимать во внимание.

//Применение оператора new вместе с типами значений

// В связи с изложенным выше возникает резонный вопрос: почему оператор new нецелесообразно
// применять к переменным таких типов значений, как int или float?
// В C# переменная типа значения содержит свое собственное значение. Память для хранения
// этого значения выделяется автоматически во время прогона программы. Следовательно,
// распределять память явным образом с помощью оператора new нет никакой
// необходимости.С другой стороны, в переменной ссылочного типа хранится ссылка на
// объект, и поэтому память для хранения этого объекта должна распределяться динамически
// во время выполнения программы.

// Благодаря тому что основные типы данных, например int или char, не преобразуются
// в ссылочные типы, существенно повышается производительность программы.
// Ведь при использовании ссылочного типа существует уровень косвенности, повышающий
// издержки на доступ к каждому объекту. Такой уровень косвенности исключается
// при использовании типа значения.

// Но ради интереса следует все же отметить, что оператор new разрешается использовать
// вместе с типами значений, как показывает следующий пример.

// int i = new int();

// При этом для типа int вызывается конструктор, инициализирующий по умолчанию
// переменную i нулевым значением. В качестве примера рассмотрим такую программу.

//Использовать оператор new вместе с типом значения.
using System;

class NewValue
{
    static void Main()
    {
        int i = new int(); //инициализировать переменную i нулевым значением

        Console.WriteLine("Значение переменной i равно: " + i);

        //Задержка программы.
        Console.ReadKey();
    }
}

// Выполнение этой программы дает следующий результат.

// Значение переменной i равно: 0

// Как показывает результат выполнения данной программы, переменная i инициализируется
// нулевым значением. Напомним, что если не применить оператор new, то
// переменная i окажется неинициализированной. Это может привести к ошибке при
// попытке воспользоваться ею в операторе, содержащем вызов метода WriteLine(),
// если предварительно не задать ее значение явным образом.

// В общем, обращение к оператору new для любого типа значения приводит к вызову
// конструктора, используемого по умолчанию для данного типа. Но в этом случае память
// динамически не распределяется. Откровенно говоря, в программировании обычно
// не принято пользоваться оператором new вместе с типами значений.