// Ключевое слово this можно также использовать в конструкторе. В этом случае оно
// обозначает объект, который конструируется. Например, следующие операторы в методе
// Rect()

// Width = w;
// Height = h;

// можно было бы написать таким образом.

// this.Width = w;
// this.Height = h;

// Разумеется, такой способ записи не дает в данном случае никаких преимуществ.
// Ради примера ниже приведен весь класс Rect, написанный с использованием ссылки this.

using System;

class Rect
{
    public int Width;
    public int Height;

    public Rect(int w, int h)
    {
        this.Width = w;
        this.Height = h;
    }

    public int Area()
    {
        return this.Width * this.Height;
    }
}

class UseRect
{
    static void Main()
    {
        Rect r1 = new Rect(4, 5);
        Rect r2 = new Rect(7, 9);

        Console.WriteLine("Площадь прямоугольника r1: " + r1.Area());
        Console.WriteLine("Площадь прямоугольника r2: " + r2.Area());

        //Задержка программы.
        Console.ReadKey();
    }
}

// В действительности ключевое слово this не используется приведенным выше
// способом в программировании на С#, поскольку это практически ничего не дает, да
// и стандартная форма записи намного проще и понятнее. Тем не менее ключевому слову
// this можно найти не одно полезное применение. Например, в синтаксисе C# допускается
// называть параметр или локальную переменную тем же именем, что и у переменной
// экземпляра. В этом случае имя локальной переменной скрывает переменную
// экземпляра. Для доступа к скрытой переменной экземпляра и служит ключевое слово
// this. Например, приведенный ниже код является правильным с точки зрения синтаксиса
// C# способом написания конструктора Rect().

// public Rect(int Width, int Height)
// {
//    this.Width = Width;
//    this.Height = Height;
// }

// В этом варианте написания конструктора Rect() имена параметров совпадают
// с именами переменных экземпляра, а следовательно, скрывают их. Но для "обнаружения"
// скрытых переменных служит ключевое слово this.