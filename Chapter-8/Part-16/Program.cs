// Перегрузка методов

// В C# допускается совместное использование одного и того же имени двумя или более
// методами одного и того же класса, при условии, что их параметры объявляются
// по-разному. В этом случае говорят, что методы перегружаются, а сам процесс называется
// перегрузкой методов. Перегрузка методов относится к одному из способов реализации
// полиморфизма в С#.

// В общем, для перегрузки метода достаточно объявить разные его варианты, а об
// остальном позаботится компилятор. Но при этом необходимо соблюсти следующее
// важное условие: тип или число параметров у каждого метода должны быть разными.
// Совершенно недостаточно, чтобы два метода отличались только типами возвращаемых
// значений. Они должны также отличаться типами или числом своих параметров.
// (Во всяком случае, типы возвращаемых значений дают недостаточно сведений компилятору
// С#, чтобы решить, какой именно метод следует использовать.) Разумеется,
// перегружаемые методы могут отличаться и типами возвращаемых значений. Когда
// вызывается перегружаемый метод, то выполняется тот его вариант, параметры которого
// соответствуют (по типу и числу) передаваемым аргументам.

// Ниже приведен простой пример, демонстрирующий перегрузку методов.

//Продемонстрировать перегрузку методов.
using System;

class OverLoad
{
    public void OvlDemo()
    {
        Console.WriteLine("Без параметров");
    }

    //Перегрузка метода OvlDemo с одним целочисленным параметром.
    public void OvlDemo(int a)
    {
        Console.WriteLine("Один параметр: " + a);
    }

    //Перегрузка метода OvlDemo с двумя целочисленными параметрами.
    public int OvlDemo(int a, int b)
    {
        Console.WriteLine("Два параметра: " + a + " " + b);
        return a + b;
    }

    //Перегрузка метода OvlDemo с двумя параметрами типа double.
    public double OvlDemo(double a, double b)
    {
        Console.WriteLine("Два параметра типа double: " + a + " " + b);
        return a + b;
    }
}

class OverloadDemo
{
    static void Main()
    {
        OverLoad ob = new OverLoad();
        int resI;
        double resD;

        //Вызвать все варианты метода OvlDemo().
        ob.OvlDemo();
        Console.WriteLine();

        ob.OvlDemo(2);
        Console.WriteLine();

        resI = ob.OvlDemo(4, 6);
        Console.WriteLine("Результат вызова метода ob.OvlDemo(4, 6): " + resI);
        Console.WriteLine();

        resD = ob.OvlDemo(1.1, 2.32);
        Console.WriteLine("Результат вызова метода ob.OvlDemo(1.1, 2.32): " + resD);
        Console.WriteLine();

        //Задержка программы.
        Console.ReadKey();
    }
}

// Вот к какому результату приводит выполнение приведенного выше кода.

// Без параметров

// Один параметр: 2

// Два параметра: 4 6
// Результат вызова метода ob.OvlDemo(4, 6): 10

// Два параметра типа double: 1.1 2.32
// Результат вызова метода ob.OvlDemo(1.1, 2.32): 3.42

// Как видите, метод OvlDemo() перегружается четыре раза. Первый его вариант не
// получает параметров, второй получает один целочисленный параметр, третий — два
// целочисленных параметра, а четвертый — два параметра типа double. Обратите также
// внимание на то, что два первых варианта метода OvlDemo() возвращают значение
// типа void, а по существу, не возвращают никакого значения, а два других — возвращают
// конкретное значение. И это совершенно допустимо, но, как пояснялось выше,
// тип возвращаемого значения не играет никакой роли для перегрузки метода. Следовательно,
// попытка использовать два разных (по типу возвращаемого значения) варианта
// метода OvlDemo() в приведенном ниже фрагменте кода приведет к ошибке.

// // Одно объявление метода OvlDemo(int) вполне допустимо.
// public void OvlDemo(int a)
// {
//    Console.WriteLine("Один параметр: " + a);
// }
// /* Ошибка! Два объявления метода OvlDemo(int) не допускаются, хотя они и возвращают разнотипные значения. */
// public int OvlDemo(int a)
// {
//    Console.WriteLine("Один параметр: " + a);
//    return a * a;
// }

// Как следует из комментариев к приведенному выше коду, отличий в типах значений,
// возвращаемых обоими вариантами метода OvlDemo(), оказывается недостаточно
// для перегрузки данного метода.