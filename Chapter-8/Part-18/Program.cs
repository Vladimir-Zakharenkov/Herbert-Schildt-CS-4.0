// Следует, однако, иметь в виду, что неявные преобразования типов выполняются
// лишь в том случае, если отсутствует точное соответствие типов параметра и аргумента.
// В качестве примера ниже приведена чуть измененная версия предыдущей программы,
// в которую добавлен вариант метода MyMeth(), где указывается параметр типа byte.

// Добавить метод MyMeth(byte).
using System;

class Overload2
{
    public void MyMeth(byte x)
    {
        Console.WriteLine("В методе MyMeth(byte): " + x);
    }

    public void MyMeth(int x)
    {
        Console.WriteLine("В методе MyMeth(int): " + x);
    }

    public void MyMeth(double x)
    {
        Console.WriteLine("В методе MyMeth(double): " + x);
    }
}

class TypeConv
{
    static void Main()
    {
        Overload2 ob = new Overload2();

        int i = 10;
        double d = 10.1;

        byte b = 99;
        short s = 10;
        float f = 11.5F;

        ob.MyMeth(i); //вызвать метод ob.MyMeth(int)
        ob.MyMeth(d); //вызвать метод MyMeth(double)

        ob.MyMeth(b); //вызвать метод ob.MyMeth(byte) -- на этот раз без  преобразования типа

        ob.MyMeth(s); //вызвать метод ob.MyMeth(int) -- с преобразованием типа
        ob.MyMeth(f); //вызвать метод ob.MyMeth(double) -- с преобразованием типа

        //Задержка программы.
        Console.ReadKey();
    }
}

// В этой программе присутствует вариант метода MyMeth(), принимающий аргумент
// типа byte, поэтому при вызове данного метода с аргументом типа byte выбирается
// его вариант MyMeth(byte) без автоматического преобразования в тип int.

// Оба модификатора параметров, ref и out, также учитываются, когда принимается
// решение о перегрузке метода. В качестве примера ниже приведен фрагмент кода, в котором
// определяются два совершенно разных метода.

// public void MyMeth(int x)
// {
//    Console.WriteLine("В методе MyMeth(int): " + x);
// }
// public void MyMeth(ref int x)
// {
//    Console.WriteLine("В методе MyMeth(ref int): " + x);
// }

// Следовательно, при обращении

// ob.MyMeth(i)

// вызывается метод MyMeth(int x), но при обращении

// ob.MyMeth(ref i)

// вызывается метод MyMeth(ref int x).

// Несмотря на то что модификаторы параметров ref и out учитываются, когда принимается
// решение о перегрузке метода, отличие между ними не столь существенно.

// Например, два следующих варианта метода MyMeth() оказываются недействительными.

// // Неверно!
// public void MyMeth(out int x)
// { // ...
// public void MyMeth(ref int x)
// { // ...

// В данном случае компилятор не в состоянии различить два варианта одного и того
// же метода MyMeth() только на основании того, что в одном из них используется параметр
// out, а в другом — параметр ref.

// Перегрузка методов поддерживает свойство полиморфизма, поскольку именно таким
// способом в C# реализуется главный принцип полиморфизма: один интерфейс —
// множество методов. Для того чтобы стало понятнее, как это делается, обратимся к
// конкретному примеру. В языках программирования, не поддерживающих перегрузку
// методов, каждому методу должно быть присвоено уникальное имя. Но в программировании
// зачастую возникает потребность реализовать по сути один и тот же метод
// для обработки разных типов данных. Допустим, что требуется функция, определяющая
// абсолютное значение. В языках, не поддерживающих перегрузку методов, обычно
// приходится создавать три или более вариантов такой функции с несколько отличающимися,
// но все же разными именами. Например, в С функция abs() возвращает абсолютное
// значение целого числа, функция labs() — абсолютное значение длинного
// целого числа, а функция fabs() — абсолютное значение числа с плавающей точкой
// обычной(одинарной) точности.

// В С перегрузка не поддерживается, и поэтому у каждой функции должно быть свое,
// особое имя, несмотря на то, что все упомянутые выше функции, по существу, делают
// одно и то же — определяют абсолютное значение. Но это принципиально усложняет
// положение, поскольку приходится помнить имена всех трех функций, хотя они реализованы
// по одному и тому же основному принципу. Подобные затруднения в С# не возникают,
// поскольку каждому методу, определяющему абсолютное значение, может быть
// присвоено одно и то же имя. И действительно, в состав библиотеки классов для среды
// .NET Framework входит метод Abs(), который перегружается в классе System.Math для
// обработки данных разных числовых типов.Компилятор C# сам определяет, какой именно
// вариант метода Abs() следует вызывать, исходя из типа передаваемого аргумента.

// Главная ценность перегрузки заключается в том, что она обеспечивает доступ к связанным
// вместе методам по общему имени. Следовательно, имя Abs обозначает общее
// выполняемое действие, а компилятор сам выбирает конкретный вариант метода по
// обстоятельствам. Благодаря полиморфизму несколько имен сводятся к одному. Несмотря
// на всю простоту рассматриваемого здесь примера, продемонстрированный
// в нем принцип полиморфизма можно расширить, чтобы выяснить, каким образом
// перегрузка помогает справляться с намного более сложными ситуациями в программировании.

// Когда метод перегружается, каждый его вариант может выполнять какое угодно
// действие. Для установления взаимосвязи между перегружаемыми методами не существует
// какого - то одного правила, но с точки зрения правильного стиля программирования
// перегрузка методов подразумевает подобную взаимосвязь. Следовательно,
// использовать одно и то же имя для несвязанных друг с другом методов не следует,
// хотя это и возможно. Например, имя Sqr можно было бы выбрать для методов, возвращающих
// квадрат и квадратный корень числа с плавающей точкой. Но ведь это
// принципиально разные операции. Такое применение перегрузки методов противоречит
// ее первоначальному назначению. На практике перегружать следует только тесно
// связанные операции.

// В C# определено понятие сигнатуры, обозначающее имя метода и список его параметров,
// Применительно к перегрузке это понятие означает, что в одном классе не
// должно существовать двух методов с одной и той же сигнатурой. Следует подчеркнуть,
// что в сигнатуру не входит тип возвращаемого значения, поскольку он не учитывается,
// когда компилятор C# принимает решение о перегрузке метода. В сигнатуру не входит
// также модификатор params.