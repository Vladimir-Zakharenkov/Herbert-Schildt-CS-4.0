// Инициализаторы объектов

// Инициализаторы объектов предоставляют еще один способ создания объекта и инициализации
// его полей и свойств. (Подробнее о свойствах речь пойдет в главе 10.) Если
// используются инициализаторы объектов, то вместо обычного вызова конструктора
// класса указываются имена полей или свойств, инициализируемых первоначально задаваемым
// значением. Следовательно, синтаксис инициализатора объекта предоставляет
// альтернативу явному вызову конструктора класса. Синтаксис инициализатора объекта
// используется главным образом при создании анонимных типов в LINQ-выражениях.
//(Подробнее об анонимных типах и LINQ-выражениях — в главе 19.) Но поскольку инициализаторы
//объектов можно, а иногда и должно использовать в именованном классе,
//то ниже представлены основные положения об инициализации объектов.

//Обратимся сначала к простому примеру.

//Простой пример, демонстрирующий применение инициализаторов объектов.
using System;

class MyClass
{
    public int Count;
    public string Str;
}

class ObjInitDemo
{
    static void Main()
    {
        //Сконструировать объект типа MyClass, используя инициализаторы объектов.
        MyClass obj = new MyClass { Count = 100, Str = "Тестирование" };

        Console.WriteLine(obj.Count + " " + obj.Str);

        //Задержка программы.
        Console.ReadLine();
    }
}

// Выполнение этого кода дает следующий результат.

// 100 Тестирование

// Как показывает результат выполнения приведенного выше кода, переменная экземпляра
// obj.Count инициализирована значением 100, а переменная экземпляра obj.Str — символьной строкой
// "Тестирование". Но обратите внимание на то, что в классе
// MyClass отсутствуют явно определяемые конструкторы и не используется обычный
// синтаксис конструкторов. Вместо этого объект obj класса MyClass создается с помощью
// следующей строки кода.

// MyClass obj = new MyClass { Count = 100, Str = "Тестирование" };

// В этой строке кода имена полей указываются явно вместе с их первоначальными
// значениями. Это приводит к тому, что сначала конструируется экземпляр объекта
// типа MyClass (с помощью неявно вызываемого по умолчанию конструктора), а затем
// задаются первоначальные значения переменных Count и Str данного экземпляра.

// Следует особо подчеркнуть, что порядок указания инициализаторов особого значения
// не имеет. Например, объект obj можно было бы инициализировать и так, как показано ниже.

// MyClass obj = new MyClass { Str = "Тестирование", Count = 100 };

// В этой строке кода инициализация переменной экземпляра Str предшествует
// инициализации переменной экземпляра Count, а в приведенном выше коде все происходило
// наоборот. Но в любом случае результат получается одинаковым.

// Ниже приведена общая форма синтаксиса инициализации объектов:

// new имя_класса { имя = выражение, имя = выражение, ...}

// где имя обозначает имя поля или свойства, т.е. доступного члена класса, на который
// указывает имя_класса. А выражение обозначает инициализирующее выражение, тип
// которого, конечно, должен соответствовать типу поля или свойства.

// Инициализаторы объектов обычно не используются в именованных классах, как, например,
// в представленном выше классе MyClass, хотя это вполне допустимо. Вообще,
// при обращении с именованными классами используется синтаксис вызова обычного
// конструктора. И, как упоминалось выше, инициализаторы объектов применяются в
// основном в анонимных типах, формируемых в LINQ-выражениях.